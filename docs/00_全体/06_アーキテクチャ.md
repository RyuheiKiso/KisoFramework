# アーキテクチャ

---

## 概要

本ドキュメントは、KisoFrameworkのシステムアーキテクチャ全体像、設計方針、構成要素、技術スタック、拡張性・保守性・セキュリティ等の観点を整理し、今後の開発・運用の指針とする。

---

## 目的

- システム全体の構造・設計思想を明確化し、関係者間の共通認識を形成する。
- 拡張性・保守性・セキュリティ・標準化を担保し、長期的な運用・進化を可能とする。
- チーム間の連携や開発効率向上、品質確保を実現する。

---

## 基本方針

- オープンかつ拡張性の高いアーキテクチャを採用し、将来の技術変化に柔軟に対応。
- モジュール化・コンポーネント化を徹底し、必要な機能を柔軟に組み合わせ可能とする。
- APIファースト設計により、システム間連携や外部拡張を容易にする。
- AIモデル連携・標準APIプロトコルとしてMCP（Model Context Protocol）を採用し、AIサービスの拡張性・相互運用性を高める。
- クラウドネイティブ技術（コンテナ、マイクロサービス、CI/CD等）を積極的に導入。
- セキュリティ・品質・パフォーマンスを重視し、企業システムとしての信頼性を確保。
- **カオスエンジニアリングを導入し、障害注入によるレジリエンス検証を継続的に実施。**

---

## MCP（Model Context Protocol）対応

KisoFrameworkでは、AIモデルや外部AIサービスとの連携において**MCP（Model Context Protocol）**を標準プロトコルとして採用する。

- **MCP概要**  
  MCPはGoogleが提唱するAIモデルとアプリケーション間の共通プロトコルであり、モデルの入出力やツール呼び出し、メタデータなどを標準化することで、異なるAIモデル間でも同じ形式でやり取りできる。

- **採用理由・メリット**
  - 異なるAIモデルやサービス間での互換性・拡張性が高まる
  - モデルの切り替えや複数モデルの統合が容易
  - オープン仕様のため独自実装や拡張も可能

- **今後の方針**
  - 共通基盤APIにMCP準拠のエンドポイントを実装
  - AIモデル連携機能はMCP形式で統一し、将来的なAIサービス拡張に備える

---

## 全体構成図

```mermaid
graph TD
  User[ユーザー]
  IndividualUI[個別画面]
  CommonUI[共通画面]
  CommonAPI[共通基盤API]
  IndividualAPI[個別API]
  IndividualPlatform[個別基盤]
  DB[データベース/外部サービス]
  Infra[インフラ基盤]
  MCPNode["MCP (Model Context Protocol)"]
  AIModelNode["AIモデル/AIサービス"]

  User -- HTTP(S) --> IndividualUI
  User -- HTTP(S) --> CommonUI
  IndividualUI -- REST/GraphQL/WebSocket --> CommonAPI
  CommonUI -- REST/GraphQL/WebSocket --> CommonAPI
  CommonAPI -- REST/gRPC --> IndividualAPI
  CommonAPI -- SQL/NoSQL/外部API --> DB
  CommonAPI -- gRPC/REST --> Infra
  CommonAPI -- REST/gRPC --> IndividualPlatform
  IndividualAPI -- REST/gRPC --> IndividualPlatform
  IndividualPlatform -- SQL/NoSQL/外部API --> DB
  IndividualPlatform -- gRPC/REST --> Infra

  %% MCP/AI連携
  CommonAPI -- MCP --> MCPNode
  MCPNode -- gRPC/REST --> AIModelNode
  AIModelNode -- gRPC/REST --> MCPNode
  MCPNode -- MCP --> CommonAPI
```

---

## システム構成要素

- **共通基盤**  
  コア機能、認証認可、ロギング、設定管理、APIゲートウェイ等の共通サービスを提供。

- **共通画面**  
  システム全体で利用する設定画面、管理画面等。

- **個別API**  
  各業務システム向けのAPI群。業務要件に応じたビジネスロジックを実装。

- **個別画面**  
  業務要件に応じた個別UI。ユーザー操作を受け付け、APIと連携。

- **個別基盤**  
  業務領域特有のビジネスルールを共通化し、再利用可能な基盤を設計・開発・運用。

- **インフラ基盤**  
  クラウド環境（例：AWS, Azure, GCP）、コンテナオーケストレーション（Kubernetes等）、CI/CDパイプライン。

- **データベース/外部サービス**  
  RDBMS、NoSQL、外部API、認証基盤等。

---

## 技術スタック

### 共通基盤チーム

- **バックエンド**
  - Rust
  - Go
  - Python
- **API設計**
  - REST
  - OpenAPI (Swagger)
  - gRPC
  - GraphQL
  - WebSocket
- **データベース**
  - PostgreSQL
  - MongoDB
- **インフラ・運用**
  - Docker
  - Kubernetes
  - AWS / Azure / GCP
  - GitHub Actions（CI/CD）
- **共通サービス**
  - 認証認可：OAuth2.0, OpenID Connect, Azure AD
  - ロギング/監視：Prometheus, Grafana, ELK Stack

### 共通画面チーム

- **フロントエンド**
  - React
  - TypeScript
  - Material-UI
- **テスト・品質管理**
  - Jest
  - Cypress
  - Playwright
  - Storybook
- **デザイン**
  - Figma
  - Adobe XD

### 個別APIチーム

- **バックエンド**
  - Node.js（Express, NestJS）
  - .NET Core
  - Java（Spring Boot）
- **API設計**
  - REST
  - GraphQL
  - OpenAPI (Swagger)
- **データベース**
  - PostgreSQL
  - MySQL
  - MongoDB
- **外部連携**
  - 各種外部API
  - Webhook

### 個別画面チーム

- **フロントエンド**
  - React
  - TypeScript
  - Next.js
  - Tailwind CSS
  - Material-UI
- **ネイティブアプリ**
  - Windowsアプリ：.NET（WPF, UWP, WinForms）
  - iOSアプリ：Swift, SwiftUI
- **テスト・品質管理**
  - Jest
  - Cypress
  - Playwright
- **デザイン**
  - Figma
  - Adobe XD

### 個別基盤チーム

- **バックエンド**
  - Node.js（Express, NestJS）
  - .NET Core
  - Java（Spring Boot）
- **API設計**
  - REST
  - GraphQL
  - OpenAPI (Swagger)
- **データベース**
  - PostgreSQL
  - MySQL
  - MongoDB
- **共通化基盤**
  - 業務ルール共通化モジュール
  - 再利用API
- **外部連携**
  - 各種外部API
  - Webhook

---

## モジュール構成

- **共通基盤モジュール**
  - 認証認可モジュール
  - 設定管理モジュール
  - ロギング・監視モジュール
  - APIゲートウェイ

- **共通画面モジュール**
  - 設定画面
  - 管理画面
  - 共通UI部品

- **個別APIモジュール**
  - 業務API（各業務ごとに分割）
  - 外部連携API

- **個別画面モジュール**
  - 業務画面（各業務ごとに分割）

- **個別基盤モジュール**
  - 業務領域特有のビジネスルール共通化基盤
  - 再利用API・サービス

---

## データフロー

1. ユーザーが個別画面または共通画面から操作
2. 個別画面が**必ず共通基盤APIを経由して**個別APIまたは共通APIを呼び出し
3. 共通APIは個別APIや個別基盤サービスを経由し、必要に応じてデータベースや外部サービスと連携
4. 共通APIはAIモデル連携時、MCP（Model Context Protocol）を介してAIモデル/AIサービスと通信
5. 個別APIや個別基盤も必要に応じてデータベースや外部サービスと連携
6. 結果を画面に返却

```mermaid
sequenceDiagram
  participant User
  participant IndividualUI as 個別画面
  participant CommonUI as 共通画面
  participant CommonAPI as 共通基盤API
  participant IndividualAPI as 個別API
  participant IndividualPlatform as 個別基盤
  participant MCP as MCP
  participant AIModel as AIモデル/AIサービス
  participant DB

  User->>IndividualUI: 操作
  User->>CommonUI: 操作
  IndividualUI->>CommonAPI: APIリクエスト
  CommonUI->>CommonAPI: APIリクエスト
  CommonAPI->>IndividualAPI: 個別API呼び出し
  CommonAPI->>IndividualPlatform: 共通化基盤呼び出し
  CommonAPI->>DB: データアクセス
  %% AI連携
  CommonAPI->>MCP: MCPリクエスト
  MCP->>AIModel: AIモデル呼び出し
  AIModel-->>MCP: AI応答
  MCP-->>CommonAPI: MCPレスポンス
  IndividualAPI->>IndividualPlatform: 共通化基盤呼び出し
  IndividualAPI->>DB: データアクセス
  IndividualPlatform->>DB: データアクセス
  DB-->>IndividualPlatform: データ返却
  IndividualPlatform-->>IndividualAPI: 結果返却
  IndividualPlatform-->>CommonAPI: 結果返却
  IndividualAPI-->>CommonAPI: 結果返却
  CommonAPI-->>IndividualUI: レスポンス
  CommonAPI-->>CommonUI: レスポンス
  IndividualUI-->>User: 画面表示
  CommonUI-->>User: 画面表示
```

---

## セキュリティ設計

- **認証認可**  
  OAuth2.0, OpenID Connect, Passkey/FIDO2等によるシングルサインオン、ロールベースアクセス制御、パスワードレス認証
- **Zero Trustセキュリティ**  
  全通信・全アクセスを信頼せず検証するZero Trustモデルを標準化
- **通信の暗号化**  
  全通信をTLS/SSLで暗号化
- **脆弱性対策**  
  静的解析（SAST）、動的解析（DAST）、依存ライブラリの脆弱性スキャン、SBOM（Software Bill of Materials）自動生成をCI/CDに組み込み
- **監査ログ**  
  重要操作・アクセスログの記録と監査、OpenTelemetryによる分散トレーシング
- **インフラセキュリティ**  
  クラウドセキュリティベストプラクティス（IAM、ネットワーク分離、WAF、CSPM等）を遵守
- **レジリエンス検証（カオスエンジニアリング）**  
  本番相当環境で障害注入テストを実施し、障害発生時の回復力・耐障害性を継続的に検証・強化。

---

## 拡張性・保守性への配慮

- モジュール化・疎結合設計により、機能追加・変更の影響範囲を最小化
- APIファースト設計で外部連携や新規サービス追加が容易
- インフラはIaC（Infrastructure as Code）で管理し、環境構築・変更を自動化
- ドキュメント・標準化を徹底し、属人化を防止
- **カオスエンジニアリングの実践により、障害に強いシステム運用・改善サイクルを確立**

---

## 標準化・ガイドライン

- コーディング規約・設計ガイドラインを整備し、全体で統一
- API設計はOpenAPI仕様に準拠し、APIドキュメント自動生成・AIレビューを導入
- UI/UXはデザインシステム・コンポーネントガイドラインを策定し、AIによるUIレビューやアクセシビリティチェックも活用
- CI/CD・自動テスト・レビュー体制を標準化し、AIによる自動テスト生成・コードレビューを積極活用

---

## 今後の展望

- AI/LLMエージェント連携、AIワークフロー自動化、AI UXのさらなる強化
- サーバーレス、エッジコンピューティング、マイクロフロントエンド等の新技術の継続的な導入
- オープンソース化や社外コミュニティとの連携強化
- 利用状況・課題のAI分析と改善サイクルの高速化
- グローバル展開や多言語対応の検討

---

## カオスエンジニアリングの流れ

KisoFrameworkでは、システムのレジリエンス（耐障害性）を高めるためにカオスエンジニアリングを導入しています。  
以下はカオスエンジニアリングの基本的な流れを示したものです。

```mermaid
flowchart TD
    A[正常稼働中のシステム] --> B[障害シナリオ設計]
    B --> C[障害注入（カオス実験）]
    C --> D[システムの挙動観測]
    D --> E{期待通りのレジリエンスか？}
    E -- Yes --> F[知見を記録・共有]
    E -- No --> G[改善策の検討・実装]
    G --> H[再度カオス実験]
    H --> D
    F --> I[運用・自動化]
```

- **障害シナリオ設計**: どのような障害（例：ネットワーク遅延、サーバーダウン等）を注入するか計画
- **障害注入**: 本番相当環境で意図的に障害を発生させる
- **挙動観測**: システムの回復力や影響範囲を監視・記録
- **改善サイクル**: 問題があれば設計・運用を改善し、再度検証

---

