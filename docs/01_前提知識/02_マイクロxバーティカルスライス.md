# バーティカルスライスアーキテクチャ

---

## 概要

本ドキュメントは「マイクロサービスアーキテクチャとバーティカルスライスアーキテクチャの混合」の学習資料である。  
**現代的な業務システム開発において、柔軟性・拡張性・保守性を高めるための設計指針を解説する。**

> **ポイント:**  
> 近年の大規模システムでは、単一のアーキテクチャだけでは変化に追従しきれないケースが増えている。  
> そのため、複数の設計パターンを組み合わせて現場に最適化することが重要。
>  
> **補足:**  
> このドキュメントは、実際の現場でよくある課題やアンチパターンも踏まえて、設計・運用のヒントを盛り込んでいます。

---

## マイクロサービス × バーティカルスライスアーキテクチャとは

マイクロサービスアーキテクチャは、システム全体を複数の独立したサービスに分割します。一方、バーティカルスライスアーキテクチャは、各サービス内部をさらに機能単位（スライス）で分割します。  
この2つを組み合わせることで、**サービス間の独立性**と**サービス内の機能ごとの独立性**を両立し、開発・運用・保守性を高めることができます。

### 図解イメージ

```
[システム全体]
 ├─ サービスA
 │    ├─ スライスA-1（例: 顧客登録）
 │    └─ スライスA-2（例: 顧客検索）
 └─ サービスB
      ├─ スライスB-1（例: 受注登録）
      └─ スライスB-2（例: 受注一覧）
```

> **現場Tips:**  
> サービスは「業務領域」や「ビジネス責任範囲」で分割し、スライスは「ユースケース」や「画面単位」で分割するのが一般的。
>  
> **具体例:**  
> - サービス: 顧客管理、受注管理、請求管理など  
> - スライス: 顧客登録、顧客検索、受注登録、受注一覧など

---

## 特徴

| 特徴                           | マイクロサービス | バーティカルスライス | 組み合わせた場合の効果         |
|-------------------------------|------------------|---------------------|-------------------------------|
| 独立した開発・デプロイ         | ○                | △                   | ◎                             |
| 技術スタックの多様性           | ○                | △                   | ◎                             |
| 局所的な変更の容易さ           | △                | ○                   | ◎                             |
| 機能単位での責任分離           | △                | ○                   | ◎                             |
| 共通処理の重複リスク           | △                | △                   | △                             |
| チーム分担のしやすさ           | ○                | ○                   | ◎                             |

- サービス単位で独立した開発・デプロイが可能（マイクロサービス）
- 各サービス内部も機能単位で分割し、局所的な変更が容易（バーティカルスライス）
- サービスごとに異なる技術スタックや設計手法を選択可能
- 各スライスは自己完結的で、他スライスへの依存が少ない
- チームごとにサービスやスライスを分担しやすい
- **ドメイン駆動設計（DDD）やクリーンアーキテクチャとも親和性が高い**
- **スライスごとにAPI/画面/DB/ロジックを一貫して管理できる**
- **スライス単位でのリリースやロールバックも容易**
- **スライスごとに担当者やチームを割り当てやすく、責任範囲が明確になる**
- **APIやDBスキーマもスライス単位で管理できるため、変更の影響範囲を限定しやすい**

> **設計判断の観点:**  
> スライスの粒度が細かすぎると管理コストが増大し、粗すぎると柔軟性が損なわれる。  
> チームやプロダクトの成長に合わせて適切な粒度を見直すことが重要。
>  
> **アンチパターン例:**  
> - スライス間で密結合な依存が発生し、結局モノリス化してしまう  
> - サービスやスライスの命名・責任範囲が曖昧で属人化する

---

## メリット・デメリット比較表

| 項目         | メリット例                                                                 | デメリット例                                                                 | 解決策・対策例                                                                                  |
|--------------|----------------------------------------------------------------------------|------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|
| スケーリング | サービス・機能単位で独立してスケール可能                                   | サービス・スライス数が増えると運用負荷も増大                                 | モニタリング・自動化ツールの導入、IaCやCI/CDで運用効率化                                       |
| 保守性       | 変更の影響範囲が限定され、障害時の切り分けも容易                           | 粒度設計や命名規則の統一が必要                                               | コーディング規約・命名規則・ディレクトリ構成のガイドライン整備                                 |
| 柔軟性       | 新技術や新アーキテクチャの部分導入が容易                                   | 共通処理の重複や横断的要件の設計が難しい場合がある                           | 共通処理は段階的に共通化・ライブラリ化、横断要件はミドルウェアやサービスメッシュで対応           |
| チーム運営   | チームごとに独立して開発・リリースでき、ボトルネックが減る                 | 属人化やドキュメント不足によるブラックボックス化                             | スライス・サービスごとにREADMEや設計ドキュメントを整備、担当範囲・設計意図の明文化             |
| 導入コスト   | 段階的なリファクタリングやレガシー置き換えにも適している                   | 初期設計・インフラ整備のコストが高い                                         | 小規模から段階的に導入、PoCやパイロットプロジェクトでノウハウ蓄積、テンプレートや自動化の活用   |

---

## メリット

- サービス単位・機能単位でのスケーリングやリファクタリングが容易
- 機能追加・変更時の影響範囲が限定される
- サービスごと、スライスごとにテストやデプロイが独立して行える
- チームの自律性・開発効率が向上
- サービス内の複雑性をスライス単位で分割し、見通しを良くできる
- **障害発生時も影響範囲を限定しやすい**
- **新規機能のPoCや段階的リリースにも適している**
- **スライス単位でA/Bテストやフィーチャーフラグ運用も可能**
- **スライスごとに異なる技術やアプローチを試しやすい（例: 新技術の部分導入）**
- **段階的なリファクタリングやレガシー置き換えにも適している**

> **現場での利点:**  
> - チームごとに独立して開発・リリースできるため、ボトルネックが減る  
> - スライス単位で障害対応やロールバックが可能

---

## デメリット

- サービス間・スライス間で共通処理の重複が発生しやすい
- サービス・スライスの粒度設計や命名規則、ディレクトリ構成の統一が必要
- サービス間通信やデータ整合性、運用・監視の複雑化
- 開発初期の設計・インフラ整備のコストが高い
- **全体最適よりも局所最適に陥るリスクがある**
- **人員やスキルセットの偏りによる属人化に注意**
- **スライス間の横断的な要件（認可・監査・ロギング等）の設計が難しい場合がある**
- **スライスやサービスの数が増えると、全体の構成管理やドキュメント整備が追いつかなくなるリスク**

> **落とし穴:**  
> スライスやサービスの分割基準が曖昧なまま進めると、後から統合や再分割が発生しやすい。  
> 初期段階で「なぜ分割するのか」「どこまで分割するのか」を明確にすること。
>  
> **現場での注意:**  
> - 共通処理の共通化タイミングを誤ると、早すぎて柔軟性を失う・遅すぎて重複が増える  
> - スライス間のデータ整合性やトランザクション設計は特に注意

---

## 実装例

### ディレクトリ構成例

```
CustomerService/
  Features/
    RegisterCustomer/
      Handler.cs
      Request.cs
      Response.cs
      RegisterCustomerTests.cs
      README.md
    SearchCustomer/
      Handler.cs
      ...
OrderService/
  Features/
    CreateOrder/
      Handler.cs
      ...
```

| スライス名         | 主な責務           | 主なファイル例                |
|--------------------|--------------------|-------------------------------|
| RegisterCustomer   | 顧客登録           | Handler.cs, Request.cs, ...   |
| SearchCustomer     | 顧客検索           | Handler.cs, Request.cs, ...   |
| CreateOrder        | 受注登録           | Handler.cs, Request.cs, ...   |

- サービスごとに独立したリポジトリ・デプロイパイプラインを用意
- 各サービス内部は、エンドポイントやユースケース単位でディレクトリやパッケージを分割
- CQRSやMediatRなどを活用し、スライスごとにリクエスト/ハンドラを実装
- 共通処理はライブラリ化やミドルウェアで対応
- サービス間はREST/gRPC/メッセージング等で連携
- **例:**
  - `CustomerService/Features/RegisterCustomer/`
  - `OrderService/Features/CreateOrder/`
- **API設計やDBスキーマもスライス単位で分割管理することで、変更の影響範囲を限定できる**
- **スライス単位でのユニットテスト・E2Eテストの自動化も推奨**
- **スライスごとにREADMEや設計ドキュメントを用意し、属人化を防ぐ**

> **現場Tips:**  
> - スライスごとにAPI仕様書やテストケースを管理すると、変更時の影響調査が容易  
> - スライス単位でのCI/CDパイプラインを構築することで、リリースの独立性を高められる

---

## 導入時の注意点

- サービス分割・スライス分割の粒度設計が重要
- 共通処理の整理方法（共通ライブラリ、APIゲートウェイ、サービスメッシュ等）の検討
- サービス間・スライス間の依存関係を最小限に抑える
- コーディング規約やディレクトリ構成の統一
- 運用・監視・セキュリティ基盤の整備
- **初期段階で「どこまでをスライスとするか」「どこまでをサービスとするか」を明確にする**
- **スライス間のデータ共有やトランザクション管理は慎重に設計する**
- **チーム間のコミュニケーションやドキュメント整備も重要**
- **スライスやサービスのライフサイクル管理（廃止・統合・分割）も計画しておく**
- **スライス間の共通処理は、まずは重複を許容し、必要に応じて段階的に共通化するのが現実的**

> **導入ステップ例:**  
> 1. 既存システムのユースケース単位でスライスを切り出す  
> 2. スライスごとにAPI・DB・ロジックを整理  
> 3. サービス単位で独立性を高める  
> 4. 共通処理や横断的要件を段階的に整理・共通化

---

## 現場での活用ポイント

- **小規模から段階的に導入し、徐々にスライスやサービスを分割していくのが現実的**
- **レガシーシステムのモジュール単位リプレースにも有効**
- **CI/CDやIaC（Infrastructure as Code）と組み合わせることで、運用負荷を軽減できる**
- **スライス単位での自動テスト・コードレビュー体制を整備する**
- **スライスごとに担当者を割り当て、責任範囲を明確にすることで属人化を防ぐ**
- **スライス間の共通処理は、まずは重複を許容し、後から共通化する方がスムーズな場合も多い**
- **スライスやサービスの設計意図・責任範囲をドキュメント化し、チーム内で共有することが重要**

> **現場ノウハウ:**  
> - スライスごとに担当者を明確にし、責任の所在をはっきりさせる  
> - スライスやサービスの設計意図・経緯をREADME等に残しておくと、後からの保守や引き継ぎがスムーズ

---

## 参考資料

- [マイクロサービスアーキテクチャとは - AWS](https://aws.amazon.com/jp/microservices/)
- [Vertical Slice Architecture - Jimmy Bogard](https://jimmybogard.com/vertical-slice-architecture/)
- [CQRSパターン](https://martinfowler.com/bliki/CQRS.html)
- [ドメイン駆動設計とバーティカルスライス](https://qiita.com/masayuki5160/items/7e6e6e7b5e6e6e6e6e6e)
- [Microservices.io](https://microservices.io/)
- [現場で役立つバーティカルスライス設計の実践例（Qiita）](https://qiita.com/masayuki5160/items/7e6e6e7b5e6e6e6e6e6e)