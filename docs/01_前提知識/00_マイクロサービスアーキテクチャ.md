# マイクロサービスアーキテクチャ

---

## 概要

本ドキュメントは「マイクロサービスアーキテクチャ」の学習資料である。

---

## マイクロサービスアーキテクチャとは

マイクロサービスアーキテクチャとは、アプリケーションを複数の小さな独立したサービス（マイクロサービス）に分割し、それぞれが独立して開発・デプロイ・スケーリングできるように設計するアーキテクチャスタイルです。各サービスは独自のデータストアやビジネスロジックを持ち、APIやメッセージングなどを通じて連携します。

### モノリシックアーキテクチャとの比較

- **モノリシックアーキテクチャ**: すべての機能が1つのアプリケーションとして構築・デプロイされる。変更やスケール時に全体へ影響が及びやすい。
- **マイクロサービスアーキテクチャ**: 各機能が独立したサービスとして分離されており、個別に開発・運用・スケールが可能。

---

## 特徴

- 各サービスは独立して開発・デプロイ可能
- サービスごとに異なる技術スタックを選択可能
- 小規模なチームでサービス単位の開発が可能
- サービス間はネットワーク越しに通信（REST, gRPC, メッセージング等）
- **自己完結性・自律性**: 各サービスは独自のデータベースやストレージを持ち、他サービスに依存しない設計が推奨される
- **データベース分離**: サービス間でデータベースを共有しないことで、独立性と障害局所化を実現

---

## メリット

- 開発・デプロイの独立性向上（例：一部サービスのみのリリースが可能）
- スケーラビリティの向上（必要なサービスのみスケール可能）
- 障害の局所化（1サービスの障害が全体に波及しにくい）
- 技術的多様性の許容（サービスごとに最適な言語やフレームワークを選択可能）
- チームの自律性向上（ドメインごとにチームを分割しやすい）

---

## デメリット

- サービス間通信の複雑化（ネットワーク越しの呼び出し、API管理、セキュリティ対策が必要）
- トランザクション管理の難易度上昇（分散トランザクションや最終的整合性の考慮が必要）
- 運用・監視の複雑化（サービス数増加に伴い、監視・ロギング・トレーシングが重要）
- 分散システム特有の課題（ネットワーク遅延、障害対応、サービスディスカバリなど）
- 開発初期のオーバーヘッド（インフラやCI/CD、運用基盤の整備が必要）

---

## 代表的な技術スタック

- API通信: REST, gRPC, GraphQL
- サービスディスカバリ: Consul, Eureka
- コンテナ: Docker, Kubernetes
- メッセージング: RabbitMQ, Kafka
- モニタリング: Prometheus, Grafana
- CI/CD: Jenkins, GitHub Actions
- **APIゲートウェイ**: Kong, Ambassador, AWS API Gateway
- **サービスメッシュ**: Istio, Linkerd

---

## 導入時の注意点

- サービス分割の粒度設計が重要（ビジネスドメインや境界づけられたコンテキストを意識）
- サービス間の契約（API仕様）の明確化とバージョニング戦略
- 運用・監視基盤の整備（分散トレーシング、集中ロギング、メトリクス収集）
- 組織・チーム体制の見直し（DevOpsやスクラムなどの導入も検討）
- セキュリティ対策（認証・認可、通信の暗号化、ゼロトラスト設計）
- データ整合性や分散トランザクションの設計
- サービス間の障害伝播やサーキットブレーカー等の耐障害性設計

---

## ユースケース例

- 大規模なECサイトやSaaSプロダクト
- 頻繁な機能追加・変更が求められるサービス
- 複数チームが並行して開発する大規模プロジェクト
- サービスごとに異なるスケーリング要件や技術要件がある場合

---

## アンチパターン

- **マイクロモノリス**: サービスを分割したが、実際には密結合で独立性がない
- **過剰な分割**: 必要以上に小さなサービスに分割し、運用・管理コストが増大
- **データベース共有**: 複数サービスで1つのDBを共有し、独立性や障害局所化が損なわれる
- **API設計の不統一**: サービス間APIの設計・管理がバラバラで、連携が困難になる

---

## 設計・運用のベストプラクティス

- サービス境界はビジネスドメインや組織構造に合わせて設計する（ドメイン駆動設計の活用）
- サービス間の通信は非同期メッセージングを積極的に活用し、疎結合を保つ
- API仕様はOpenAPI等でドキュメント化し、契約テストを導入する
- サービスごとにCI/CDパイプラインを整備し、独立デプロイを徹底する
- サービス監視・障害検知・自動復旧の仕組みを導入する
- サーキットブレーカーやリトライ、タイムアウト等の耐障害性設計を行う

---

## 導入判断のポイント

- サービス分割によるメリット（開発速度、スケーラビリティ、障害局所化等）が、運用コスト増加を上回るか
- 組織やチームの規模、開発・運用体制がマイクロサービスに適しているか
- インフラ・運用基盤（CI/CD、監視、サービスディスカバリ等）が整備できるか
- サービス間のデータ整合性やトランザクション要件を満たせるか

---

## 参考資料

- [マイクロサービスアーキテクチャとは - AWS](https://aws.amazon.com/jp/microservices/)
- [マイクロサービスパターン - マーチン・ファウラー](https://martinfowler.com/microservices/)
- [Microservices.io](https://microservices.io/)
- [Google Cloud - マイクロサービスの設計原則](https://cloud.google.com/architecture/microservices-architecture?hl=ja)
- [サーバントリーダーシップとマイクロサービス](https://www.infoq.com/jp/articles/servant-leadership-microservices/)
